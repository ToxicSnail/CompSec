#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

struct Element  //определение структуры элемента стека
{
    char symbol;    //символ, который будет храниться в элементе стека
    struct Element* next;   //указатель на следующий элемент стека
};

struct Stack    //определение структуры элемента стека
{
    int size;   //количество элементов в стеке
    struct Element* Top;    //указатель на верхний элемент стека
};

typedef struct Element Element;  //переименование структуры Element в Element
typedef struct Stack Stack;     //переименование структуры Stack в Stack

bool Push(Stack*, char);    //объявление функции для добавления элемента в стек
bool Pop(Stack*, char*);    //объявление функции для удаления элемента из стека
bool ShowTop(Stack*, char*);    //объявление функции для получения верхнего элемента стека
bool isEmpty(Stack*);   //объявление функции для проверки наличия элементов в стеке
bool isExpressionCorrect(char*);    //объявление функции для проверки корректности математического выражения
bool Clear(Stack*); //объявление функции для очистки стека

bool isLowerCase(char);     //объявление функции для проверки, является ли символ буквой в нижнем регистре
bool isOperationSign(char); //объявление функции для проверки, является ли символ знаком операции
bool isDigit(char);     //объявление функции для проверки, является ли символ цифрой

int main(int argc, char const* argv[])
{

    char expression[16];    //определение массива для хранения математического выражения
    scanf("%s", &expression);   //ввод математического выражения
    if (isExpressionCorrect(expression))    //если математическое выражение корректно
        printf("Correct\n");    //вывести сообщение о корректности выражения
    else
        printf("Incorrect\n");  //иначе вывести сообщение об ошибке
    return 0;   // завершение работы программы
}

bool Push(Stack* stack, char symbol)    //функция для добавления элемента в стек
{
    Element* element = (Element*)malloc(sizeof(Element));   //выделение памяти под новый элемент стека
    if (!element)   //если выделение памяти не удалось
        return false;   //вернуть ложь

    element->symbol = symbol;   //присвоение символа новому элементу стека
    element->next = NULL;       //

    if (!stack->Top)            //если стек пуст, новый элемент становится вершиной стека
        stack->Top = element;   //
    else                                
    {                                   ////иначе новый элемент становится вершиной, 
        element->next = stack->Top;     //а старая вершина - следующим элементом новой вершины
        stack->Top = element;           //
    }
    stack->size++;      //увеличиваем размер стека
    return true;        //возвращаем true
}

bool Pop(Stack* stack, char* symbol)
{
    if (!symbol)        //проверяем, передан ли указатель на переменную symbol
        return false;   //если нет, функция возвращает false
    if (!stack->Top)        //проверяем, есть ли элементы в стеке
        return false;       //если стек пуст, функция возвращает false

    *symbol = (*stack).Top->symbol; //значение символа верхнего элемента стека сохраняется в указанной переменной symbol
    Element* newTop = (*stack).Top->next;   //указатель на следующий элемент стека сохраняется в переменной newTop
    free(stack->Top);   //освобождается память, выделенная для верхнего элемента стека
    stack->Top = newTop;    //указатель Top обновляется, указывая на следующий элемент стека
    stack->size--;  //размер стека уменьшается на 1
    return true;    //функция возвращает true
}

bool ShowTop(Stack* stack, char* symbol)
{
    if (!symbol)        //проверяем, передан ли указатель на переменную symbol
        return false;   //если нет, функция возвращает false
    if (!stack->Top)        //проверяем, есть ли элементы в стеке
        return false;       //если стек пуст, функция возвращает false
    *symbol = stack->Top->symbol;   //запись символа верхнего элемента стека в переменную, на которую указывает аргумент symbol
    return true;    //функция возвращает true
}

bool isEmpty(Stack* stack)
{
    if (stack->Top)         //если стек пуст, то stack->Top равен NULL 
        return false;       //и функция возвращает true
    return true;            //если стек не пуст, то функция возвращает false
}

bool isExpressionCorrect(char* expression)
{
    if (!expression)    //проверяем, что строка expression не является пустой.
        return false;

    Stack* stack = (Stack*)malloc(sizeof(Stack));   //создается стек stack
    if (!stack)
        return false;
    stack->size = 0;    //стек инициализируется пустым
    stack->Top = NULL;  //
    char* symbol = (char*)malloc(sizeof(char)); //создается переменная symbol, которая будет использоваться для хранения символов из стека
    int i = 0, j = 0;
    bool end_of_expr = false;

    while (!end_of_expr)    //в цикле происходит перебор всех символов expression
    {
        Push(stack, expression[i]); //каждый символ добавляется в стек с помощью функции Push.
        if (expression[i] == ')')                               //если текущий символ - закрывающая скобка )
        {                                                       //то из стека последовательно извлекаются символы до тех пор, 
            Pop(stack, symbol);                                 //пока не будет достигнута соответствующая открывающая скобка (
            while (ShowTop(stack, symbol) && *symbol != '(')    
            {
                Pop(stack, symbol);
                if (j == 0 && (isLowerCase(*symbol) || isDigit(*symbol)))   //если j = 0, то извлеченный символ должен быть буквой в нижнем регистре или цифрой
                {                                                           //
                    j = (j + 1) % 3;                                        //
                }                                                           //
                else if (j == 1 && isOperationSign(*symbol))    //если j = 1, то извлеченный символ должен быть знаком операции
                {                                               //    
                    j = (j + 1) % 3;                            //
                }                                               //
                else if (j == 2 && (isLowerCase(*symbol) || isDigit(*symbol)))  //если j = 2, то извлеченный символ должен быть буквой в нижнем регистре или цифрой 
                {                                                               //
                    j = (j + 1) % 3;                                            //после этого j устанавливается в 0,
                    Push(stack, 'r');                                           //а в стек добавляется символ r
                }                                                               //
                else                                                                //иначе
                {                                                                   //
                    Clear(stack);                                                   //очищаем стек
                    return false;                                                   //возвращаем false, так как выражение некорректно.
                }
            }
            Pop(stack, symbol);
            Push(stack, 'r');
            j = 0;
        }

        if (expression[i + 1] == 0) //проверяем, достигнут ли конец строки
        {
            while (!isEmpty(stack)) //проверяем, пока стек не пустой.
            {
                Pop(stack, symbol); //извлекаем символ из стека и сохраняем его в переменную symbol
                if (j == 0 && (isLowerCase(*symbol) || isDigit(*symbol)))   //если j = 0, то извлеченный символ должен быть буквой в нижнем регистре или цифрой
                {                                                           //
                    j = (j + 1) % 3;                                        //увеличиваем j на 1 и берем остаток от деления j на 3.
                }                                                           //
                else if (j == 1 && isOperationSign(*symbol))    //если j = 1, то извлеченный символ должен быть знаком операции
                {                                               //
                    j = (j + 1) % 3;                            //увеличиваем j на 1 и берем остаток от деления j на 3.
                }                                               //
                else if (j == 2 && (isLowerCase(*symbol) || isDigit(*symbol)))  //если j = 2, то извлеченный символ должен быть буквой в нижнем регистре или цифрой
                {                                                               //
                    j = (j + 1) % 3;                                            //увеличиваем j на 1 и берем остаток от деления j на 3.
                    Push(stack, 'r');                                           //добавляем в стек символ 'r'
                }                                                               //
                else                //если ни одно из условий выше не выполняется, то очищаем стек
                {                   //
                    Clear(stack);   //очищаем стэк
                    return false;   //возвращаем false, так как выражение некорректно.
                }                   //
            }                       //
            end_of_expr = true; // устанавливаем флаг, что мы достигли конца выражения
        }
        ++i; //инкрементируем i для перехода к следующему символу в строке.
    }

    if (j == 2)         //если переменная j равна 2
        return false;   //значит выражение не было правильно сформировано, и функция возвращает false
    return true;        //в противном случае функция возвращает true.
}

bool Clear(Stack* stack)
{
    if (!stack->Top)    //если указатель на вершину стека пуст
        return true;    //то функция сразу возвращает true, так как стек уже пуст
    Element* next = (Element*)1;    // Объявляется указатель на следующий элемент стека и инициализируется ненулевым значением для начала работы цикла
    while (next)    //запускается цикл, который будет работать до тех пор, 
    {               //пока указатель next на следующий элемент не станет нулевым, что означает достижение конца стека
        next = (*stack).Top->next;  //запоминается указатель на следующий элемент стека
        free(stack->Top);   //освобождается память, выделенную для верхнего элемента стека
        stack->Top = next;      //верху стека присваивается значение указателя на следующий элемент
    }
    stack->size = 0;    //обнуляется размер стека
    return true;    //функция возвращает true, означающее успешную очистку стека
}

bool isLowerCase(char letter)
{
    return (letter >= 97 && letter <= 122); //используется оператор сравнения для проверки, находится ли код символа в диапазоне от 97 до 122, 
                                            //соответствующем коду букв от 'a' до 'z' в таблице ASCII. Если это так, то возвращается значение true
}

bool isOperationSign(char sign)
{
    return (sign == '+' || sign == '-' || sign == '/' || sign == '*');  //проверяем, является ли переданный символ знаком операции
}

bool isDigit(char digit)
{
    return (digit >= '0' || digit <= '9');  //проверяем, является ли переданный символ цифрой(0-9).
}

/*
Алгоритм работы программы следующий:

1.Считывается строка с математическим выражением с помощью функции scanf.

2.Вызывается функция isExpressionCorrect, которая принимает на вход строку с выражением и возвращает значение типа bool.

3.Внутри функции isExpressionCorrect создается пустой стек, в котором будут храниться символы выражения.

4.Происходит проход по всем символам в строке выражения. Если символ является закрывающей скобкой, то из стека извлекаются все символы до открывающей скобки.

5.Для каждого извлеченного символа проверяется его тип. Если символ является буквой или цифрой и он находится на четной позиции после открывающей скобки, то устанавливается переменная j в 1. Если символ является знаком операции и он находится на нечетной позиции после открывающей скобки или на четной позиции после знака операции, то устанавливается переменная j в 2. Если символ является буквой или цифрой и он находится на нечетной позиции после знака операции, то устанавливается переменная j в 0 и в стек добавляется символ 'r'. Если символ не удовлетворяет ни одному из перечисленных условий, то выражение считается некорректным и программа возвращает false.

6.Если программа дошла до конца строки и переменная j равна 2, то выражение считается некорректным и программа возвращает false.

7.Если программа прошла все проверки, то выражение считается корректным и программа возвращает true.
*/
